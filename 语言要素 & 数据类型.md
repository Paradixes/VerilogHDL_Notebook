# 语言要素 & 数据类型

## 语言要素

### 1. 空白符

包含 **空格符 (\b)、制表符(\t)、换行符和换页符**，在编译和综合时，通常被忽略，但可以增加程序可读性，使代码具有层次感

```verilog
//eg.
initial begin a = 3'b100; b = 3'b010; end;
//compared with
initial
begin
    a = 3'b100;
    b = 3'b010;
end;
```



### 2. 注释符

**和C语言完全一致**

+ 单行注释：`//`开始，该行结束为止
+ 多行注释：`/*`开始，`*/`



### 3. 标识符

可以是 **字母、数字、$ 和 _ ** 符号的组合，但标识符区分大小写，并且第一个字符 **必须是字母或下划线**



### 4. 转义标识符

以`\`符号开头，空白结尾（基本无用）



### 5. 关键字

不允许被修改，由系统内部的命令宏变量等组成，在IDE中会以颜色区分



### 6. 数值

#### (1) 四种基本逻辑数值状态

| 状态 |       含义       |
| :--: | :--------------: |
|  0   |  低电平，逻辑0   |
|  1   |  高电平，逻辑1   |
| x或X | 不确定或未知逻辑 |
| z或Z |      高阻态      |

#### (2) 整数及其表示

+ **`+/- < size >'< base_format >< number >`**

	|   数制   | 基数符号 |            合法标识符             |
	| :------: | :------: | :-------------------------------: |
	|  二进制  |  b 或 B  |     0, 1, x, X, z, Z, ?, ...      |
	|  八进制  |  o 或 O  |      0~7, x, X, z, Z, ?, ...      |
	|  十进制  |  d 或 D  |      0~9, x, X, z, Z, ?, ...      |
	| 十六进制 |  h 或 H  | 0~9, a~f, A~F, x, X, z, Z, ?, ... |

+ 1位十六进制数 = 4个位宽，1位八进制数 = 3个位宽

+ 负数数值形式可以以补码形式表示
+ 由于二进制过长，因而引用八进制或是十六进制
+ \<size>可以省略，但最好不要省略

```verilog
//correct
8'b10_001_101	//位宽8的二进制10001101(下划线可用来提高可读性，但不能置于数)
8'ha6			//位宽8的十六进制数a6
5'o35			//位宽5的八进制数35
4'd6			//位宽4的十进制数6
4'b1X_01		//位宽4的二进制数1x01

//wrong
4'd-4			//数值不能为负，负号应放最左边
3' b001			//'和基数b之间不能出现空格
(4+4)'b11		//位宽不能以表达式形式出现
```

#### (3) 实数及其表示

+ 十进制表示法，采用十进制格式，小数点两边必须有数字，eg. `3.0`
+ 科学计数法，e不区分大小写，eg. `5.2e8`

+ 实数不能用于电路设计，只能用于测试和仿真



## 数据类型

### 1. 物理数据类型及其声明

#### (1) 连线型

**`< net_declaration >< drive_strength >< range >< delay >[ list_of_variables ]`**

+ `net_declaration`：连接形式

	| 连线型数据类型  |           功能说明            |
	| :-------------: | :---------------------------: |
	|  `wire`, `tri`  | 缺省形式：0, 1或X；0, 1, X或Z |
	| `wor`, `trior`  |   多重驱动时，具有线或特征    |
	| `wand`, `trand` |   多重驱动时，具有线与特征    |
	|    `trireg`     | 具有电荷保持特性的连续型数据  |
	|     `tri1`      |           上拉电阻            |
	|     `tri0`      |           下拉电阻            |
	|    `supply1`    |       电源线，为高电平1       |
	|    `supply0`    |       电源线，为高电平0       |

+ `drive_strength`：电源驱动能力（表中由强至弱排序）

  |  标记符  |    名称    | 类型 |
  | :------: | :--------: | :--: |
  | `supply` | 电源级驱动 | 驱动 |
  | `strong` |   强驱动   | 驱动 |
  |  `pull`  | 上拉级驱动 | 驱动 |
  | `large`  |   大容性   | 存储 |
  |  `weak`  |   弱驱动   | 驱动 |
  | `medium` |  中性驱动  | 存储 |
  | `small`  |   小容性   | 存储 |
  | `highz`  |   高容性   | 高阻 |

+ `range`：用来指定数据为标量还是矢量，缺省状态为1位的标量，超过1则为矢量

+ `delay`：仿真延迟时间

+ `list_of_variables`：变量名称，一次可定义多个，用逗号分隔

```verilog
tri[7:0] tribus;				//定义一个8位的三态总线
tri0[15:0] busa;				//定义一个16位的连线型，处于三态时为上拉电阻
tri1[31:0] busb;				//定义一个32位的连线型，处于三态时为下拉电阻
wire(pull1,strong0)c = a + b;	//定义一个4为的标量型寄存器矢量
trireg(large) storeline;		//定义一个具有大强度电荷存储功能的存储线
```

  

#### (2) 寄存器型

+ reg型是数据存储单位的抽象类型
+ reg型变量常用于行为级描述，由过程赋值语句对其进行赋值


**`reg < range >[ list_of_variables ]`**

+ `range`为可选项，同上
+ `list_of_variables`同上

	```verilog
//eg.
reg a;					//定义一个一位的名为a的reg变量
reg [3:0]b;				//定义一个4位的名为b的reg型变量
reg [8:1]c, d, e;		//定义三个名称分别为c, d, e的8位reh型变量
	```

+ reg型变量一般为无符号数，若将负数赋值给reg型变量，则自动转换为补码形式

	```verilog
//eg.
reg signed[3:0] rega;
rega = -2;				//rega的值为1110(14)，是2的补码
	```



#### (3) 存储器型

+ 存储器型变量可以描述RAM型、ROM型存储器以及reg文件

**`reg < range1 >< name_of_register >< range2 >`**

+ `range1`和`range2`都是可选项，缺省为1
+ `range1`：表示存储器中寄存器的位宽，格式为`[msb:lsb]`
+ `range2`：表示寄存器的个数，格式为`[msb:lsb]`，即有 $msb-lsb+1$ 个寄存器

+ `name_of_register`变量名称，同上

```verilog
//eg.
reg [7:0]mem1[255:0];	//定义了一个有256个八位寄存器的存储器，地址范围是0~255
reg [n - 1:0] a;		//定义一个n位的寄存器a
reg mem1[n - 1:0];		//定义一个由n个1位寄存器构成的存储器
```



### 2. 抽象数据类型

#### (1) 整型

整型数据常用于对循环控制变量的说明，在算术运算符中被视为二进制补码形式的有符号数。除了寄存器型数据被当做无符号数来处理之外，整型数据与32位寄存器型数据在实际意义上相同。

`integer <list_of_variables>`

#### (2) 时间型

64位的无符号数。时间型数据主要用于对模拟时间的存储和计算处理，常与系统函数$time一起使用

`time <list_of_register_variables>`

#### (3) 实型

实型数据在机器码中是浮点型数值，可用于对延迟时间的计算

`real  <list_of_variables>`

#### (4) 参数型

参数在仿真开始之前被赋值，仿真过程中保持不变

采用参数定义方法可以提高程序的可读性和维护性

参数常用来定义延迟时间和变量的位宽

parameter 参数名 = 表达式

类似于宏定义