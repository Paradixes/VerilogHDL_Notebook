# 任务和函数

可以将较大行为级设计划分为较小的代码段，允许设计者将重复部分提取出来，减少代码量

## 任务

如果子程序满足以下任一条件，则公共子程序的描述中必须使用任务而不能使用函数：

+ 子程序中包含有延迟、时序或者事件控制结构

+ 没有输出或者输入变量的数量大于1

+ 没有输入变量

### 1. 定义

```verilog
task <任务名>;
    端口和类型声明
    局部变量声明
    begin
        语句1;
        语句2;
    end
endtask
```



### 2. 注意事项

+ 任务名后不能出现输入输出端口列表
+ 任务中可以有延时语句、敏感事件控制语句等事件控制语句
+ 任务可以没有或可以有一个或多个输入、输出和双向端口
+ 任务可以没有返回值，也可以通过输出端口或双向端口返回一个或多个值
+ 任务可以调用其它的任务和函数，也可以调用该任务本身
+ 任务定义结构内不允许出现过程块（ `initial` 或 `always` ）
+ 任务定义结构内可以出现`disable`终止语句，这条语句的执行将中断正在执行的任务。任务被中断后，程序流程将返回到调用任务的地方继续向下执行



### 3. 任务的调用

+ 调用任务不需要实例名，端口列表顺序与定义相同：`<任务名>(端口1, 端口2,...)`

+ 模块只能调用它内部构造的任务，不能调用其他模块定义的任务

+ 使用任务可以使程序更加简洁易懂

```verilog
//eg.
module demo_task_invo_tb;
    reg [7:0] mem[127:0];
    reg [15:0] a;
    reg [31:0] b;
    initial
        begin
            a = 0;
            read_mem(a, b); //第一次调用
            #10;
            a = 64;
            read_mem(a, b); //第二次调用
        end
    
    task read_mem; //任务定义部分
        input [15:0] address;
        output [31:0] data;
        reg [3:0] counter;
        reg [7:0] temp[1:4];
        begin
            for(counter = 1; counter <= 4; counter = counter + 1)
                temp[counter] = mem[address + counter - 1];
            data = {temp[1], temp[2], temp[3], temp[4]};
        end
    endtask
endmodule
```



## 函数

对于一个子程序，如果下面的所有条件成立，则可以使用函数来完成

+ 子程序内不含有延迟、时序或者事件控制结构
+ 子程序只有一个返回值
+ 至少有一个输入变量
+ 没有输出或者双向变量
+ 不含有非阻塞赋值语句

### 1. 定义

```verilog
function <返回值类型或位宽> <函数名>;
    输入参量与类型声明
    局部变量声明
    begin
        语句1;
        语句2;
        ...
    end
endfunction
```



### 2. 注意事项

+ 与任务一样，函数定义结构只能出现在模块中，而不能出现在过程块内。
+ 函数至少必须有一个输入端口。
+ 函数不能有任何类型的输出端口和双向端口。
+ 在函数定义结构中的行为语句不能出现任何类型的时间控制描述，也不允许使用 `disable` 终止语句
+ 与任务定义一样，函数定义内部结构不能出现过程块。
+ 在一个函数内可以其他函数进行调用，但是函数不能调用其它任务。
+ 在第一行`function`语句中不能出现端口名列表。
+ 函数声明的时候，在 Verilog 内部隐含地声明了一个名为 function_identifier 的寄存器类型变量，函数的输出结果将通过这个寄存器变量被传递回来。



### 3. 函数调用

+ `函数名(<输入表达式1>, <输入表达式2>, ... )`

```verilog
//eg.
module tryfact_tb;
    function [31:0] factorial;
        input [3:0] operand;
        reg [3:0] index;
        begin
            factorial = 1;
            for(index = 1; index <= oprand; index = index + 1)
                factorial = index * factorial;
        end
    endfunction
    
    reg [31:0] result;
    reg [3:0] n;
    initial
        begin
            result = 1;
            for(n = 1; n <= 9; n = n + 1)
                begin
                    result = factorial(n);
                    $display("n=%d result=%d", n, result);
                end
        end
endmodule
```



## 任务和函数的区别

|                      函数                      |                      任务                      |
| :--------------------------------------------: | :--------------------------------------------: |
|   函数能调用另一个函数，但不能调用另一个任务   |    任务能调用另一个任务，也能调用另一个函数    |
|        函数总是在仿真时刻 0 就开始执行         |          任务可以在非 0 仿真时刻执行           |
| 函数一定不能包含任何延迟、时序或者事件控制语句 |   任务可以包含延迟、时序或者事件控制声明语句   |
|             函数至少有一个输入变量             |   任务可以没有或者有多个输入、输出和双向变量   |
|  函数只能返回一个值，函数不能有输出或双向变量  | 任务不返回任何值，但可以通过输出变量传递多个值 |
|            函数不能作为一条语句出现            |  任务的调用是通过一条单独的任务调用语句实现的  |
|    函数调用可以出现在过程块或连续赋值语句中    |           任务调用只能出现在过程块中           |
|   函数的执行不允许由 `disable` 语句进行中断    |    任务的执行可以由 `disable` 语句进行中断     |

